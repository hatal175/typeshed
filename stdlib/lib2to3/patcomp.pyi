from typing import Any, Dict, Iterator, Optional, Sequence, Tuple, Union, overload
from typing_extensions import Literal

from . import pygram as pygram, pytree as pytree
from .pgen2 import (
    driver as driver,
    grammar as grammar,
    literals as literals,
    parse as parse,
    token as token,
    tokenize as tokenize,
)
from .pgen2.grammar import Grammar

class PatternSyntaxError(Exception): ...

def tokenize_wrapper(input: str) -> Iterator[tokenize._TokenInfo]: ...

class PatternCompiler:
    grammar: Grammar = ...
    syms: pygram.Symbols = ...
    pygrammar: Grammar = ...
    pysyms: pygram._pattern_symbols = ...
    driver: driver.Driver = ...  # noqa
    def __init__(self, grammar_file: Optional[str] = ...) -> None: ...
    @overload
    def compile_pattern(self, input: str, debug: bool, with_tree: Literal[False]) -> pytree.BasePattern: ...
    @overload
    def compile_pattern(self, input: str, debug: bool, with_tree: Literal[True]) -> Tuple[pytree.BasePattern, pytree._NL]: ...
    @overload
    def compile_pattern(
        self, input: str, debug: bool = ..., with_tree: bool = ...
    ) -> Union[pytree.BasePattern, Tuple[pytree.BasePattern, pytree._NL]]: ...
    def compile_node(self, node: pytree._NL) -> pytree.BasePattern: ...
    def compile_basic(self, nodes: Sequence[pytree._NL], repeat: Optional[pytree._NL] = ...) -> pytree.BasePattern: ...
    def get_int(self, node: pytree._NL) -> int: ...

TOKEN_MAP: Dict[str, Optional[int]]

def pattern_convert(grammar: grammar.Grammar, raw_node_info: pytree._RawNode): ...
def compile_pattern(pattern: str) -> pytree.BasePattern: ...
