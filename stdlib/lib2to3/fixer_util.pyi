from typing import Any, Iterator, List, Optional, Sequence, Set, Union

from . import patcomp as patcomp
from .pgen2 import token as token
from .pytree import _NL, Leaf as Leaf, Node as Node, _Results

def KeywordArg(keyword: _NL, value: _NL) -> Node: ...
def LParen() -> Leaf: ...
def RParen() -> Leaf: ...
def Assign(target: Union[_NL, List[_NL]], source: Union[_NL, List[_NL]]) -> Node: ...
def Name(name: str, prefix: Optional[str] = ...) -> Leaf: ...
def Attr(obj: _NL, attr: _NL) -> List[_NL]: ...
def Comma() -> Leaf: ...
def Dot() -> Leaf: ...
def ArgList(args: List[_NL], lparen: _NL = ..., rparen: _NL = ...) -> Node: ...
def Call(func_name: _NL, args: Optional[List[_NL]] = ..., prefix: Optional[str] = ...) -> Node: ...
def Newline() -> Leaf: ...
def BlankLine() -> Leaf: ...
def Number(n: int, prefix: Optional[str] = ...) -> Leaf: ...
def Subscript(index_node: _NL) -> Node: ...
def String(string: str, prefix: Optional[str] = ...) -> Leaf: ...
def ListComp(xp: _NL, fp: _NL, it: _NL, test: Optional[_NL] = ...) -> Node: ...
def FromImport(package_name: str, name_leafs: List[_NL]) -> Node: ...
def ImportAndCall(node: _NL, results: _Results, names: Sequence[str]) -> Node: ...
def is_tuple(node: _NL) -> bool: ...
def is_list(node: _NL) -> bool: ...
def parenthesize(node: _NL) -> Node: ...

consuming_calls: Set[str]

def attr_chain(obj: Any, attr: str) -> Iterator[Any]: ...

p0: str
p1: str
p2: str
pats_built: bool

def in_special_context(node: _NL) -> bool: ...
def is_probably_builtin(node: _NL) -> bool: ...
def find_indentation(node: _NL) -> str: ...
def make_suite(node: _NL) -> _NL: ...
def find_root(node: _NL) -> _NL: ...
def does_tree_import(package: str, name: str, node: _NL) -> bool: ...
def is_import(node: _NL) -> bool: ...
def touch_import(package: str, name: str, node: _NL) -> None: ...
def find_binding(name: str, node: _NL, package: Optional[str] = ...) -> Optional[_NL]: ...
