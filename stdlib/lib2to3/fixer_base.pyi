from typing import Any, Iterator, List, Mapping, Optional, Pattern, Set

from . import pygram as pygram
from .fixer_util import does_tree_import as does_tree_import
from .patcomp import PatternCompiler as PatternCompiler
from .pytree import _NL, _Results

class BaseFix:
    PATTERN: Optional[str] = ...
    pattern: Optional[Pattern] = ...
    pattern_tree: Optional[_NL] = ...
    options: Optional[Mapping[str, Any]] = ...
    filename: Optional[str] = ...
    numbers: Iterator[int] = ...
    used_names: Set[str] = ...
    order: str = ...
    explicit: bool = ...
    run_order: int = ...
    keep_line_order: bool = ...
    BM_compatible: bool = ...
    syms: pygram._python_symbols = ...
    log: List[str] = ...
    def __init__(self, options: Mapping[str, Any], log: List[str]) -> None: ...
    def compile_pattern(self) -> None: ...
    def set_filename(self, filename: str) -> None: ...
    def match(self, node: _NL) -> _Results: ...
    def transform(self, node: _NL, results: _Results) -> Optional[_NL]: ...
    def new_name(self, template: str = ...) -> str: ...
    first_log: bool = ...
    def log_message(self, message: str) -> None: ...
    def cannot_convert(self, node: _NL, reason: Optional[str] = ...) -> None: ...
    def warning(self, node: _NL, reason: str) -> None: ...
    def start_tree(self, tree: _NL, filename: str) -> None: ...
    def finish_tree(self, tree: _NL, filename: str) -> None: ...

class ConditionalFix(BaseFix):
    skip_on: Optional[str] = ...
    def start_tree(self, *args: Any) -> None: ...
    def should_skip(self, node: _NL) -> bool: ...
