import enum
import io
from _typeshed import _KT, _VT, AnyPath, ReadableBuffer, SupportsRead, SupportsWrite, _T_co
from typing import (
    Any,
    BinaryIO,
    Callable,
    Container as _Container,
    Dict,
    Generic,
    Iterable,
    List,
    Mapping as _Mapping,
    Optional as _Optional,
    Sequence as _Sequence,
    TypeVar,
    Union as _Union,
    overload,
)
from typing_extensions import Protocol

from .lib.bitstream import RebufferedBytesIO, _BytesToBytesFunc
from .lib.containers import Container, ListContainer

_T = TypeVar("_T")

class ConstructError(Exception):
    path: _Optional[str] = ...
    def __init__(self, message: str = ..., path: _Optional[str] = ...) -> None: ...

class SizeofError(ConstructError): ...
class AdaptationError(ConstructError): ...
class ValidationError(ConstructError): ...
class StreamError(ConstructError): ...
class FormatFieldError(ConstructError): ...
class IntegerError(ConstructError): ...
class StringError(ConstructError): ...
class MappingError(ConstructError): ...
class RangeError(ConstructError): ...
class RepeatError(ConstructError): ...
class ConstError(ConstructError): ...
class IndexFieldError(ConstructError): ...
class CheckError(ConstructError): ...
class ExplicitError(ConstructError): ...
class NamedTupleError(ConstructError): ...
class TimestampError(ConstructError): ...
class UnionError(ConstructError): ...
class SelectError(ConstructError): ...
class SwitchError(ConstructError): ...
class StopFieldError(ConstructError): ...
class PaddingError(ConstructError): ...
class TerminatedError(ConstructError): ...
class RawCopyError(ConstructError): ...
class RotationError(ConstructError): ...
class ChecksumError(ConstructError): ...
class CancelParsing(ConstructError): ...

class _SupportsSeek(Protocol[_T_co]):
    def seek(self, at: int, whence: int = ...) -> Any: ...

class _SupportsTell(Protocol[_T_co]):
    def tell(self) -> int: ...

class _SupportsSeekTell(_SupportsSeek[_T_co], _SupportsTell[_T_co]):
    pass

class _SupportsEOFCheck(_SupportsSeekTell[_T_co], SupportsRead[_T_co]):
    pass

def singleton(arg: Callable[[], _T]) -> _T: ...
def stream_read(stream: SupportsRead[bytes], length: int, path: _Optional[str]) -> bytes: ...
def stream_read_entire(stream: SupportsRead[bytes], path: _Optional[str]) -> bytes: ...
def stream_write(stream: SupportsWrite[bytes], data: bytes, length: int, path: _Optional[str]) -> None: ...
def stream_seek(stream: _SupportsSeek[bytes], offset: int, whence: int, path: _Optional[str]) -> Any: ...
def stream_tell(stream: _SupportsTell[bytes], path: _Optional[str]) -> int: ...
def stream_size(stream: _SupportsSeekTell[bytes]) -> int: ...
def stream_iseof(stream: _SupportsEOFCheck[bytes]) -> bool: ...

_ContextContainer = Container[str, Any]

class _ParseFunc(Protocol):
    def __call__(self, stream: SupportsRead[bytes], context: _ContextContainer, path: _Optional[str]) -> Any: ...

class CodeGen:
    blocks: List[str] = ...
    nextid: int = ...
    parsercache: Dict[int, str] = ...
    linkedinstances: Dict[int, Construct] = ...
    linkedparsers: Dict[int, _ParseFunc] = ...
    def __init__(self) -> None: ...
    def allocateId(self) -> int: ...
    def append(self, block: str) -> None: ...
    def toString(self) -> str: ...

class KsyGen:
    instances: Dict[str, Any] = ...
    enums: Dict[str, Dict[Any, str]] = ...
    types: Dict[str, Dict[str, Any]] = ...
    nextid: int = ...
    def __init__(self) -> None: ...
    def allocateId(self) -> int: ...

def hyphenatedict(d: _Mapping[str, _VT]) -> Dict[str, _VT]: ...
def hyphenatelist(l: Iterable[_Mapping[str, _VT]]) -> List[_Mapping[str, _VT]]: ...
def extractfield(sc: Subconstruct) -> Subconstruct: ...
@overload
def evaluate(param: Callable[..., _T], context: _ContextContainer) -> _T: ...
@overload
def evaluate(param: _T, context: _ContextContainer) -> _T: ...

_ParseVal = TypeVar("_ParseVal")

class Construct(Generic[_ParseVal]):
    name: _Optional[str] = ...
    docs: str = ...
    flagbuildnone: bool = ...
    parsed: Callable[[Construct, _ContextContainer], None] = ...
    def __init__(self) -> None: ...
    def __copy__(self) -> Construct: ...
    def parse(self, data: ReadableBuffer, **contextkw: Any) -> _ParseVal: ...
    def parse_stream(self, stream: BinaryIO, **contextkw: Any) -> _ParseVal: ...
    def parse_file(self, filename: AnyPath, **contextkw: Any) -> _ParseVal: ...
    def _parsereport(self, stream: BinaryIO, context: _ContextContainer, path: _Optional[str]) -> _ParseVal: ...
    def _parse(self, stream: BinaryIO, context: _ContextContainer, path: _Optional[str]) -> _ParseVal: ...
    def build(self, obj: _ParseVal, **contextkw: Any) -> bytes: ...
    def build_stream(self, obj: _ParseVal, stream: BinaryIO, **contextkw: Any) -> None: ...
    def build_file(self, obj: _ParseVal, filename: AnyPath, **contextkw: Any) -> None: ...
    def _build(self, obj: _ParseVal, stream: BinaryIO, context: _ContextContainer, path: _Optional[str]) -> Any: ...
    def sizeof(self, **contextkw: Any) -> int: ...
    def _sizeof(self, context: _ContextContainer, path: _Optional[str]) -> int: ...
    def compile(self, filename: _Optional[AnyPath] = ...) -> Compiled: ...
    def benchmark(self, sampledata: ReadableBuffer, filename: _Optional[AnyPath] = ...) -> str: ...
    def export_ksy(self, schemaname: str = ..., filename: _Optional[AnyPath] = ...) -> str: ...
    def _emitseq(self, ksy: KsyGen, bitwise: bool) -> Any: ...
    def _emitprimitivetype(self, ksy: KsyGen, bitwise: bool) -> Any: ...
    def _emitfulltype(self, ksy: KsyGen, bitwise: bool) -> Any: ...
    def __rtruediv__(self, name: str) -> Renamed: ...
    def __rdiv__(self, name: str) -> Renamed: ...
    def __mul__(self, other: Any) -> Renamed: ...
    def __rmul__(self, other: Any) -> Renamed: ...
    def __add__(self, other: Any) -> Struct: ...
    def __rshift__(self, other: Any) -> Sequence: ...
    def __getitem__(self, count: _Union[int, Callable]) -> Array: ...

class Subconstruct(Construct[_ParseVal], Generic[_ParseVal]):
    subcon: Construct[_ParseVal] = ...
    flagbuildnone: bool = ...
    def __init__(self, subcon: Construct[_ParseVal]) -> None: ...

class Adapter(Subconstruct[_ParseVal], Generic[_T, _ParseVal]):
    def _decode(self, obj: _T, context: _ContextContainer, path: _Optional[str]) -> _ParseVal: ...
    def _encode(self, obj: _ParseVal, context: _ContextContainer, path: _Optional[str]) -> _T: ...

class SymmetricAdapter(Adapter[_T, _T], Generic[_T]): ...
class Validator(SymmetricAdapter[_T], Generic[_T]): ...

class Tunnel(Subconstruct[_ParseVal], Generic[_ParseVal]):
    def _decode(self, data: bytes, context: _ContextContainer, path: _Optional[str]) -> bytes: ...
    def _encode(self, data: bytes, context: _ContextContainer, path: _Optional[str]) -> bytes: ...

_CompiledParserFunc = Callable[[BinaryIO, Any], Any]

class Compiled(Construct):
    source: _Optional[str] = ...
    defersubcon: _Optional[Construct] = ...
    parsefunc: _CompiledParserFunc = ...
    def __init__(self, source: _Optional[str], defersubcon: _Optional[Construct], parsefunc: _CompiledParserFunc) -> None: ...
    def compile(self, filename: _Optional[AnyPath] = ...) -> Compiled: ...
    def benchmark(self, sampledata: ReadableBuffer, filename: _Optional[AnyPath] = ...) -> str: ...

_TypeOrReturnsType = _Union[Callable[[_ContextContainer], _T], _T]

class Bytes(Construct[bytes]):
    length: _TypeOrReturnsType[int] = ...
    def __init__(self, length: _TypeOrReturnsType[int]) -> None: ...

class _GreedyBytes(Construct[bytes]): ...

GreedyBytes: _GreedyBytes

def Bitwise(subcon: Construct) -> Construct: ...
def Bytewise(subcon: Construct) -> Construct: ...

class FormatField(Construct[_ParseVal], Generic[_ParseVal]):
    fmtstr: str = ...
    length: int = ...
    def __init__(self, endianity: str, format: str) -> None: ...

class BytesInteger(Construct[int]):
    length: _TypeOrReturnsType[int] = ...
    signed: bool = ...
    swapped: bool = ...
    def __init__(self, length: _TypeOrReturnsType[int], signed: bool = ..., swapped: bool = ...) -> None: ...

class BitsInteger(Construct[int]):
    length: _TypeOrReturnsType[int] = ...
    signed: bool = ...
    swapped: bool = ...
    def __init__(self, length: _TypeOrReturnsType[int], signed: bool = ..., swapped: bool = ...) -> None: ...

Bit: BitsInteger
Nibble: BitsInteger
Octet: BitsInteger
Int8ub: FormatField[int]
Int16ub: FormatField[int]
Int32ub: FormatField[int]
Int64ub: FormatField[int]
Int8sb: FormatField[int]
Int16sb: FormatField[int]
Int32sb: FormatField[int]
Int64sb: FormatField[int]
Int8ul: FormatField[int]
Int16ul: FormatField[int]
Int32ul: FormatField[int]
Int64ul: FormatField[int]
Int8sl: FormatField[int]
Int16sl: FormatField[int]
Int32sl: FormatField[int]
Int64sl: FormatField[int]
Int8un: FormatField[int]
Int16un: FormatField[int]
Int32un: FormatField[int]
Int64un: FormatField[int]
Int8sn: FormatField[int]
Int16sn: FormatField[int]
Int32sn: FormatField[int]
Int64sn: FormatField[int]

Byte = Int8ub
Short = Int16ub
Int = Int32ub
Long = Int64ub

Float16b: FormatField[float]
Float16l: FormatField[float]
Float16n: FormatField[float]
Float32b: FormatField[float]
Float32l: FormatField[float]
Float32n: FormatField[float]
Float64b: FormatField[float]
Float64l: FormatField[float]
Float64n: FormatField[float]

Half = Float16b
Single = Float32b
Double = Float64b
native: Any

Int24ub: BytesInteger
Int24ul: BytesInteger
Int24un: BytesInteger
Int24sb: BytesInteger
Int24sl: BytesInteger
Int24sn: BytesInteger

class _VarInt(Construct[int]): ...

VarInt: _VarInt

class _ZigZag(Construct[int]): ...

ZigZag: _ZigZag

possiblestringencodings: Dict[str, int]

def encodingunit(encoding: str) -> bytes: ...

class StringEncoded(Adapter[bytes, str]):
    encoding: str = ...
    def __init__(self, subcon: Construct[bytes], encoding: str) -> None: ...

def PaddedString(length: _TypeOrReturnsType[int], encoding: str) -> StringEncoded: ...
def PascalString(lengthfield: _TypeOrReturnsType[int], encoding: str) -> StringEncoded: ...
def CString(encoding: str) -> StringEncoded: ...
def GreedyString(encoding: str) -> StringEncoded: ...

class _Flag(Construct): ...

Flag: _Flag

class EnumInteger(int): ...

class EnumIntegerString(str):
    intvalue: int
    def __int__(self) -> int: ...
    @staticmethod
    def new(intvalue: int, stringvalue: str) -> EnumIntegerString: ...

class Enum(Adapter[bytes, int]):
    encmapping: Dict[EnumIntegerString, int] = ...
    decmapping: Dict[int, EnumIntegerString] = ...
    ksymapping: Dict = ...
    def __init__(self, subcon: Construct, *merge: _Union[enum.IntEnum, enum.IntFlag], **mapping: int) -> None: ...
    def __getattr__(self, name: Any) -> Any: ...

class BitwisableString(str):
    def __or__(self, other: Any) -> BitwisableString: ...

class FlagsEnum(Adapter[str, Container[str, bool]]):
    flags: Dict[str, int] = ...
    reverseflags: Dict[int, str] = ...
    def __init__(self, subcon: Construct, *merge: _Union[enum.IntEnum, enum.IntFlag], **flags: int) -> None: ...
    def __getattr__(self, name: str) -> BitwisableString: ...

class Mapping(Adapter[_KT, _VT], Generic[_KT, _VT]):
    decmapping: _Mapping[_VT, _KT] = ...
    encmapping: _Mapping[_KT, _VT] = ...
    def __init__(self, subcon: Construct, mapping: _Mapping[_KT, _VT]) -> None: ...

class Struct(Construct[Container]):
    subcons: List[Construct] = ...
    flagbuildnone: bool = ...
    def __init__(self, *subcons: Construct, **subconskw: Construct) -> None: ...
    def __getattr__(self, name: str) -> Any: ...

class Sequence(Construct[ListContainer]):
    subcons: List[Construct] = ...
    flagbuildnone: bool = ...
    def __init__(self, *subcons: Construct, **subconskw: Construct) -> None: ...
    def __getattr__(self, name: Any) -> Any: ...

class Array(Subconstruct[ListContainer]):
    count: _TypeOrReturnsType[int] = ...
    discard: bool = ...
    def __init__(self, count: _TypeOrReturnsType[int], subcon: Construct, discard: bool = ...) -> None: ...

class GreedyRange(Subconstruct[ListContainer]):
    discard: bool = ...
    def __init__(self, subcon: Construct, discard: bool = ...) -> None: ...

# This can get either a three argument lambda or a 'truthy' value,
# which unfortunately means everything.
class RepeatUntil(Subconstruct[ListContainer], Generic[_T]):
    predicate: _T = ...
    discard: bool = ...
    def __init__(self, predicate: _T, subcon: Construct, discard: bool = ...) -> None: ...

class Renamed(Subconstruct[_ParseVal], Generic[_ParseVal]):
    name: str = ...
    docs: str = ...
    parsed: Callable[[Construct, _ContextContainer], None] = ...
    def __init__(
        self,
        subcon: Construct,
        newname: _Optional[str] = ...,
        newdocs: _Optional[str] = ...,
        newparsed: _Optional[Callable[[Construct, _ContextContainer], None]] = ...,
    ) -> None: ...
    def __getattr__(self, name: str) -> Any: ...

class Const(Subconstruct, Generic[_T]):
    value: _T = ...
    flagbuildnone: bool = ...
    def __init__(self, value: _T, subcon: _Optional[Construct[_T]] = ...) -> None: ...

class Computed(Construct[_T], Generic[_T]):
    func: _TypeOrReturnsType[_T] = ...
    flagbuildnone: bool = ...
    def __init__(self, func: _TypeOrReturnsType[_T]) -> None: ...

class _Index(Construct[int]):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...

Index: _Index

class Rebuild(Subconstruct[_T], Generic[_T]):
    func: _TypeOrReturnsType[_T] = ...
    flagbuildnone: bool = ...
    def __init__(self, subcon: Construct, func: _TypeOrReturnsType[_T]) -> None: ...

class Default(Subconstruct[_T], Generic[_T]):
    value: _TypeOrReturnsType[_T] = ...
    flagbuildnone: bool = ...
    def __init__(self, subcon: Construct, value: _TypeOrReturnsType[_T]) -> None: ...

class Check(Construct[_ParseVal], Generic[_T, _ParseVal]):
    func: _TypeOrReturnsType[_T] = ...
    flagbuildnone: bool = ...
    def __init__(self, func: _TypeOrReturnsType[_T]) -> None: ...

class _Error(Construct):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...

Error: _Error

class FocusedSeq(Construct[_ParseVal], Generic[_ParseVal]):
    parsebuildfrom: _TypeOrReturnsType[str] = ...
    subcons: List[Construct] = ...
    def __init__(self, parsebuildfrom: _TypeOrReturnsType[str], *subcons: Construct, **subconskw: Construct) -> None: ...

class _Pickled(Construct): ...

Pickled: _Pickled

class _Numpy(Construct): ...

Numpy: _Numpy

class NamedTuple(Adapter):
    tuplename: str = ...
    tuplefields: _Union[str, Iterable[str]] = ...
    factory: Any = ...
    def __init__(self, tuplename: str, tuplefields: _Union[str, Iterable[str]], subcon: Construct) -> None: ...

# Can also accept arrow.Arrow for epoch but no stubs for that
def Timestamp(subcon: Construct, unit: _Union[float, str], epoch: _Union[int, str, Any]) -> Construct: ...

class Hex(Adapter): ...
class HexDump(Adapter): ...

class Union(Construct):
    parsefrom: _Optional[_Union[_TypeOrReturnsType[int], _TypeOrReturnsType[str]]] = ...
    subcons: List[Construct] = ...
    def __init__(
        self, parsefrom: _Optional[_Union[_TypeOrReturnsType[int], _TypeOrReturnsType[str]]], *subcons: Any, **subconskw: Any
    ) -> None: ...
    def __getattr__(self, name: str): ...

class Select(Construct[_ParseVal], Generic[_ParseVal]):
    subcons: List[Construct] = ...
    flagbuildnone: bool = ...
    def __init__(self, *subcons: Construct, **subconskw: Construct) -> None: ...

def Optional(subcon: Construct[_ParseVal]) -> Select[_ParseVal]: ...
def If(condfunc: _T, subcon: Construct) -> IfThenElse[_T]: ...

class IfThenElse(Construct, Generic[_T]):
    condfunc: _T = ...
    thensubcon: Construct = ...
    elsesubcon: Construct = ...
    flagbuildnone: bool = ...
    def __init__(self, condfunc: _T, thensubcon: Construct, elsesubcon: Construct) -> None: ...

class Switch(Construct, Generic[_KT]):
    keyfunc: _TypeOrReturnsType[_KT] = ...
    cases: _Mapping[_KT, Construct] = ...
    default: Construct = ...
    flagbuildnone: bool = ...
    def __init__(
        self, keyfunc: _TypeOrReturnsType[_KT], cases: _Mapping[_KT, Construct], default: _Optional[Construct] = ...
    ) -> None: ...

class StopIf(Construct, Generic[_T]):
    condfunc: _T = ...
    flagbuildnone: bool = ...
    def __init__(self, condfunc: _T) -> None: ...

def Padding(length: _TypeOrReturnsType[_T], pattern: bytes = ...) -> Padded[_T, Any]: ...

class Padded(Subconstruct[_ParseVal], Generic[_T, _ParseVal]):
    length: _TypeOrReturnsType[_T] = ...
    pattern: bytes = ...
    def __init__(self, length: _TypeOrReturnsType[_T], subcon: Construct[_ParseVal], pattern: bytes = ...) -> None: ...

class Aligned(Subconstruct[_ParseVal], Generic[_ParseVal]):
    modulus: _TypeOrReturnsType[int] = ...
    pattern: bytes = ...
    def __init__(self, modulus: _TypeOrReturnsType[int], subcon: Construct[_ParseVal], pattern: bytes = ...) -> None: ...

def AlignedStruct(modulus: _TypeOrReturnsType[int], *subcons: Construct, **subconskw: Construct) -> Struct: ...
def BitStruct(*subcons: Construct, **subconskw: Construct) -> Construct: ...

class Pointer(Subconstruct[_ParseVal], Generic[_ParseVal]):
    offset: _TypeOrReturnsType[int] = ...
    stream: _TypeOrReturnsType[BinaryIO] = ...
    def __init__(
        self, offset: _TypeOrReturnsType[int], subcon: Construct[_ParseVal], stream: _Optional[_TypeOrReturnsType[BinaryIO]] = ...
    ) -> None: ...

class Peek(Subconstruct[_ParseVal], Generic[_ParseVal]):
    flagbuildnone: bool = ...
    def __init__(self, subcon: Construct[_ParseVal]) -> None: ...

class Seek(Construct):
    at: _TypeOrReturnsType[int] = ...
    whence: _TypeOrReturnsType[int] = ...
    flagbuildnone: bool = ...
    def __init__(self, at: _TypeOrReturnsType[int], whence: _TypeOrReturnsType[int] = ...) -> None: ...

class _Tell(Construct):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...

Tell: _Tell

class _Pass(Construct):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...

Pass = _Pass

class _Terminated(Construct):
    flagbuildnone: bool = ...
    def __init__(self) -> None: ...

Terminated: _Terminated

class RawCopy(Subconstruct): ...

def ByteSwapped(subcon: Construct) -> Construct: ...
def BitsSwapped(subcon: Construct) -> Construct: ...

class Prefixed(Subconstruct[_ParseVal], Generic[_ParseVal]):
    lengthfield: Construct[int] = ...
    includelength: bool = ...
    def __init__(self, lengthfield: Construct[int], subcon: Construct[_ParseVal], includelength: bool = ...) -> None: ...

def PrefixedArray(countfield: Construct[int], subcon: Construct) -> Construct: ...

class FixedSized(Subconstruct[_ParseVal], Generic[_ParseVal]):
    length: _TypeOrReturnsType[int] = ...
    def __init__(self, length: _TypeOrReturnsType[int], subcon: Construct[_ParseVal]) -> None: ...

class NullTerminated(Subconstruct[_ParseVal], Generic[_ParseVal]):
    term: bytes = ...
    include: bool = ...
    consume: bool = ...
    require: bool = ...
    def __init__(
        self, subcon: Construct[_ParseVal], term: bytes = ..., include: bool = ..., consume: bool = ..., require: bool = ...
    ) -> None: ...

class NullStripped(Subconstruct[_ParseVal], Generic[_ParseVal]):
    pad: bytes = ...
    def __init__(self, subcon: Construct[_ParseVal], pad: bytes = ...) -> None: ...

_DataFunc = _Union[bytes, io.BytesIO, Construct]

class RestreamData(Subconstruct[_ParseVal], Generic[_ParseVal]):
    datafunc: _DataFunc = ...
    flagbuildnone: bool = ...
    def __init__(self, datafunc: _DataFunc, subcon: Construct[_ParseVal]) -> None: ...

class Transformed(Subconstruct[_ParseVal], Generic[_ParseVal]):
    decodefunc: _BytesToBytesFunc = ...
    decodeamount: _Optional[int] = ...
    encodefunc: _BytesToBytesFunc = ...
    encodeamount: int = ...
    def __init__(
        self,
        subcon: Construct[_ParseVal],
        decodefunc: _BytesToBytesFunc,
        decodeamount: _Optional[int],
        encodefunc: _BytesToBytesFunc,
        encodeamount: int,
    ) -> None: ...

class Restreamed(Subconstruct[_ParseVal], Generic[_ParseVal]):
    decoder: _BytesToBytesFunc = ...
    decoderunit: int = ...
    encoder: _BytesToBytesFunc = ...
    encoderunit: int = ...
    sizecomputer: Callable[[int], int] = ...
    def __init__(
        self,
        subcon: Construct[_ParseVal],
        decoder: _BytesToBytesFunc,
        decoderunit: int,
        encoder: _BytesToBytesFunc,
        encoderunit: int,
        sizecomputer: Callable[[int], int],
    ) -> None: ...

class ProcessXor(Subconstruct[_ParseVal], Generic[_ParseVal]):
    padfunc: _Union[_TypeOrReturnsType[int], _TypeOrReturnsType[bytes]] = ...
    def __init__(
        self, padfunc: _Union[_TypeOrReturnsType[int], _TypeOrReturnsType[bytes]], subcon: Construct[_ParseVal]
    ) -> None: ...

class ProcessRotateLeft(Subconstruct[_ParseVal], Generic[_ParseVal]):
    precomputed_single_rotations: Dict[int, List[int]] = ...
    amount: _TypeOrReturnsType[int] = ...
    group: _TypeOrReturnsType[int] = ...
    def __init__(self, amount: _TypeOrReturnsType[int], group: _TypeOrReturnsType[int], subcon: Construct[_ParseVal]) -> None: ...

class Checksum(Construct):
    checksumfield: Construct[bytes] = ...
    hashfunc: Callable[[bytes], Any] = ...
    bytesfunc: Callable[[_ContextContainer], Any] = ...
    flagbuildnone: bool = ...
    def __init__(
        self, checksumfield: Construct[bytes], hashfunc: Callable[[bytes], Any], bytesfunc: Callable[[_ContextContainer], Any]
    ) -> None: ...

class Compressed(Tunnel):
    encoding: str = ...
    level: _Optional[int] = ...
    lib: Any = ...
    def __init__(self, subcon: Construct, encoding: str, level: _Optional[int] = ...) -> None: ...

class CompressedLZ4(Tunnel):
    lib: Any = ...
    def __init__(self, subcon: Construct) -> None: ...

class Rebuffered(Subconstruct[_ParseVal], Generic[_ParseVal]):
    stream2: RebufferedBytesIO = ...
    def __init__(self, subcon: Construct[_ParseVal], tailcutoff: _Optional[int] = ...) -> None: ...

class Lazy(Subconstruct[_Union[_ParseVal, Callable[[], _ParseVal]]], Generic[_ParseVal]):
    def __init__(self, subcon: Construct[_ParseVal]) -> None: ...

class LazyContainer(dict):
    def __init__(
        self,
        struct: Construct,
        stream: BinaryIO,
        offsets: _Mapping[int, int],
        values: _Mapping[int, Any],
        context: _ContextContainer,
        path: _Optional[str],
    ) -> None: ...

class LazyStruct(Construct):
    subcons: List[Construct] = ...
    flagbuildnone: bool = ...
    def __init__(self, *subcons: Construct, **subconskw: Construct) -> None: ...

class LazyListContainer(list):
    def __init__(
        self,
        subcon: Construct,
        stream: BinaryIO,
        count: int,
        offsets: _Mapping[int, int],
        values: _Mapping[int, Any],
        context: _ContextContainer,
        path: _Optional[str],
    ) -> None: ...

class LazyArray(Subconstruct):
    count: _TypeOrReturnsType[int] = ...
    def __init__(self, count: _TypeOrReturnsType[int], subcon: Construct) -> None: ...

class LazyBound(Construct):
    subconfunc: Callable[[], Construct] = ...
    def __init__(self, subconfunc: Callable[[], Construct]) -> None: ...

class ExprAdapter(Adapter[_T, _ParseVal], Generic[_T, _ParseVal]):
    def __init__(
        self,
        subcon: Construct[_ParseVal],
        decoder: Callable[[_T, _ContextContainer], _ParseVal],
        encoder: Callable[[_ParseVal, _ContextContainer], _T],
    ) -> None: ...

class ExprSymmetricAdapter(ExprAdapter[_T, _T], Generic[_T]):
    def __init__(self, subcon: Construct[_T], encoder: Callable[[_T, _ContextContainer], _T]): ...

class ExprValidator(Validator, Generic[_T]):
    def __init__(self, subcon: Construct[_T], validator: Callable[[_T, _ContextContainer], bool]) -> None: ...

def OneOf(subcon: Construct[_T], valids: _Container[_T]) -> ExprValidator[_T]: ...
def NoneOf(subcon: Construct[_T], invalids: _Container[_T]) -> ExprValidator[_T]: ...
def Filter(predicate: Callable[[_T, _ContextContainer], bool], subcon: Construct[_T]) -> ExprSymmetricAdapter[_T]: ...

class Slicing(Adapter[_Sequence[_ParseVal], _Sequence[_ParseVal]], Generic[_ParseVal]):
    count: int = ...
    start: int = ...
    stop: int = ...
    step: int = ...
    empty: _Optional[_ParseVal] = ...
    def __init__(
        self,
        subcon: Construct[_Sequence[_ParseVal]],
        count: int,
        start: int,
        stop: int,
        step: int = ...,
        empty: _Optional[_ParseVal] = ...,
    ) -> None: ...

class Indexing(Adapter[_Sequence[_ParseVal], _ParseVal], Generic[_ParseVal]):
    count: int = ...
    index: int = ...
    empty: _Optional[_ParseVal] = ...
    def __init__(
        self, subcon: Construct[_Sequence[_ParseVal]], count: int, index: int, empty: _Optional[_ParseVal] = ...
    ) -> None: ...
